# !/usr/bin/python3
# _*_ coding:utf-8 _*_
#
# Copyright (C) 2023 - 2023 pgl, Inc. All Rights Reserved 
#
# @Time    : 2023/2/21 9:30
# @Author  : pgl
# @File    : 39_正则表达式.py.py
# @IDE     : PyCharm

# 正则表达式
# 概念: 正则表达式是一种用来匹配字符串的强有力的武器. 设计思路是一种描述性的语言来给字符串定义一个规则,凡是符合规则的字符串,就认为它"匹配",否则就不匹配
# 正则表达式的8个内容
# 1. 行定位符
# 2. 元字符
# 3. 限定符
# 4. 字符类
# 5. 排除字符
# 6. 选择字符
# 7. 转义字符
# 8. 分组

# 1. 行定位符, 行定位符就是定位行的开始和结束
# ^ 表示开始:
# "HiPython Hi明日科技"
# "^Hi"
# $ 表示结束:
# "HiPython Hi明日科技"
# "科技$"就会匹配上面字符串中的'科技'

# 2. 元字符, 就是在正则表达式中具有特殊意义的专用字符
# # .     匹配除换行符以外的任意字符,1个'.'代表一个字符
# # \w    匹配字母.数字.下划线或者汉字
# # \W    匹配字母.数字.下换下或者汉字以外的字符
# # \s    匹配任意的空白符
# # \b    匹配单词的开始或结束
# # \d    匹配数字

# 3. 限定符, 用来限定匹配数量
# ?      匹配前面的字符零次或一次        colou?r:        匹配colour和color#
# +      匹配前面的字符一次或多次        go+gle:         匹配的范围从gogle到goo...gle
# *      匹配前面的字符零次或多次        go*gle:         匹配的范围从ggle到goo...gle
# {n}    匹配前面的字符n次             go{2}gle:       只匹配google
# {n,}   匹配前面的字符最少n次          go{2,}gle:      匹配的范围从google到goo...gle
# {n,m}  匹配前面的字符最少n次,最多m次   employe{0,2}    匹配employ.employe和employee

# 4. 字符类:[], 就是定义一个字符集合, 然后匹配这个集合当中字符的意思,使用[]表示 [aeiou]:匹配任意一个原音字母; [\u4e00-\u9fa5]:匹配任意一个汉字
# 5. 排除字符^:用来匹配不符合指定字符集中字符串的,使用'^'表示    '^'单独使用表示字符串开头,'^'放在[]中表示排除字符串    [^a-zA-Z]:匹配一个不是字母的字符
# 6. 选择字符|: 对于选择字符可以理解为"或",用来表示符合这个条件或符合另一个条件    [a-z]|[0-9]:匹配a--z的小写字母或者从0--9的数字
# 7. 转义字符\: 这里的转义字符用'\'表示,把一个特殊的字符变为普通的字符
# [1-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}
# [1-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}

# 8. 分组():
# (\.[0-9]{1,3}){3}:对这个分组重复3次匹配
# 在Python中使用正则表达式还需要用''把它括起来,让它变成模式字符串    '[^a-zA-Z]'
# '\\bm\\w*\\b' :以字母m开头或者结尾的字符串(每一个\都需要转义)
# r'\bm\w*\b':在模式字符砖前面加上R或者r转换成原生字啊渡船


# 使用re模块实现正则表达式操作
# 在Python中提供了re模块, re模块是可以实现正则表达式的操作, 但是在使用re模块的时候需要使用import re引用这个模块
# re模块中常用的3种方法
# 1.匹配字符串
# 2.替换字符串
# 3.使用正则表达式分割字符串

# 1.匹配字符串也就是查找字符串,主要有3中方法:match(); search(); findall()都可以实现匹配字符串
# match()方法 只是 只是 只是 从字符串的开始处进行匹配, 如果起始位置匹配成功,那么就返回一个Match的对象否则就返回None值
# re.match(pattern, string, [flags]) 第一个参数是要匹配的模式字符串, 第二个参数是要匹配的字符串, 前两个参数必选,最后一个参数是可选参数用来控制匹配方式(比如:re.l 不区分字母大小写; re.A 让\w不匹配汉字)

import re

pattern = r'mr_\w'  # 定义一个模式字符串,在''前面加上r就是使用原生字符,匹配以"mr"开头的字符串,后面跟上"\w"
string = 'MR_SHOP mr_shop'  # 要匹配的字符串
match = re.match(pattern, string, re.I)  # 匹配字符串, (re.I不区分大小写,在默认情况下是区分大小写的)
print("输出匹配结果:", match)
# 如果获取的内容不存在就不能调用下面几个方法
print("匹配的起始位置(索引值): ", match.start())
print("匹配的结束位置(索引值): ", match.end())
print("匹配的数据: ", match.group())
print('\n')

# 实例: 应用正则表达式验证输入的手机号码是否合法.
# 13634222222 是有效的中国移动手机号码.
# 13144222221 不是有效的中国移动手机号码.
import re

pattern = r'(13[4-9]\d{8})|(15[01289]\d{8})$'  # 模式字符串 13开头第3位数字在[4--9]中选择,后面是连续的8位数字
mobile = "13634222222"  # 要匹配的手机号码
match1 = re.match(pattern, mobile)  # 把匹配结果放到match1中
if match1 == None:
    print(mobile, "不是有有效的中国移动手机号码")
else:
    print(mobile, "是有效的中国移动手机号码")

print('\n')

# search()方法在整个字符串当中搜索第一个 第一个 匹配成功的值, 如果匹配成功就返回Match的对象,如果匹配不成功就返回None的值
# re.search(pattern, string, [flags])    re.方法名(模式字符串,要匹配的字符串,标志位这个标志位和match方法一样)
pattern1 = r'mr_\w'  # 定义一个模式字符串,在''前面加上r就是使用原生字符,匹配以"mr"开头的字符串,后面跟上"\w"
string1 = '项目名称: MR_SHOP mr_shop'  # 要匹配的字符串
match2 = re.search(pattern1, string1, re.I)  # 匹配字符串, (re.I不区分大小写,在默认情况下是区分大小写的)
print("输出匹配结果:", match2)
# 如果获取的内容不存在就不能调用下面几个方法
print("search方法匹配的起始位置(索引值): ", match2.start())
print("search方法匹配的结束位置(索引值): ", match2.end())
print("search方法匹配的数据: ", match2.group())

print("\n")
# 实例: 验证是否出现危险字符.
# 我是一名程序员, 我喜欢看黑客方面的数, 想研究一下Trojan. @ 出现了危险词汇!
# 我是一名程序员, 我喜欢看计算机网络方面的图书, 喜欢开发网站. @ 安全!
pattern2 = r'(黑客)|(抓包)|(监听)|(Trojan)'  # 模式字符串
about = '我是一名程序员, 我喜欢看计算机网络方面的图书, 喜欢开发网站.'
match3 = re.search(pattern2, about)
if match3 == None:
    print(about, "@ 安全!")
else:
    print(about, "@ 出现了危险词汇!")

print('\n')
# findall()用来在这个字符串当中搜索所有符合正则表达式的字符串,并且以列表的形式进行返回,如果匹配成功就会返回一个包含结果的列表,否则就返回一个空列表
# re.findall(pattern, string, [flags]) re.方法名(模式字符串, 要匹配的字符串, 标志位(这个标志位和前面的方法一样))
pattern3 = r'mr_\w'  # 定义一个模式字符串,在''前面加上r就是使用原生字符,匹配以"mr"开头的字符串,后面跟上"\w"
string3 = '项目名称: MR_SHOP mr_shop'  # 要匹配的字符串
match3 = re.findall(pattern3, string3, re.I)  # 匹配字符串, (re.I不区分大小写,在默认情况下是区分大小写的)
print("输出匹配结果是一个列表不是match对象:", match3)

# 分割字符串 split()分割之后会以列表的形式返回
# re.split(pattern, string, [maxsplit], [flags])    flags: re.I:不区分字母大小写  re.A:让\w不匹配汉字
# re.方法名称(模式字符串, 要匹配的字符串, 最大的拆分次数是一个可选次数, 标志位用来控制匹配方式的)

import re

pattern = r'[?|&]'  # 定义一个模式字符串, 设置分割符可以以是'?'可以是'&'
url = "http://www.mingrisoft.com/login.jsp?username='mr' & pwd='mrsoft'"  # 要拆分的字符串
result = re.split(pattern, url)  # 把分割结果保存到'result'这个结果当中
print(result)
print('\n')

# 实例: 应用正则表达式,从 @明日科技 @扎克伯格 @俞敏洪 @勤奋的天使 中分割出好友的名字 并保存到一个列表当中
str1 = "@明日科技 @扎克伯格 @俞敏洪 @勤奋的天使"
pattern = r'\s*@'  # 定义一个模式字符串, 设置分割符 \s:表示空白符; *:匹配前面的空白符0次或多次; @:使用@符号进行分割或者@符号前面有空格的符号分割
list1 = re.split(pattern, str1)  # 分割结果报讯在list1当中, 使用空格或单独的@分割字符串
print("您@的好友为: ")
for item in list1:  # 通过for循环遍历 list
    if item != "":  # 如果元素 item 不为空 !=: 不是的意思
        print(item)  # 输出每个好友的名字

"""
验证输入用户名和QQ号是否有效并给出对应的提示信息

要求：
用户名必须由字母、数字或下划线构成且长度在6~20个字符之间
QQ号是5~12的数字且首位不能为0
"""


def main():
    username = input('请输入用户名: ')
    qq = input('请输入QQ号: ')
    m1 = re.match(r'^[0-9a-zA-Z_]{6,20}$', username)
    if not m1:
        print('请输入有效的用户名.')
    m2 = re.match(r'^[1-9]\d{4,11}$', qq)
    if not m2:
        print('请输入有效的QQ号.')
    if m1 and m2:
        print('你输入的信息是有效的!')


if __name__ == '__main__':
    main()
